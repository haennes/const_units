# Architecture of const_units as well as config files


## Architecture of const_units

### global_types
Contains types that are needed in multiple other crates of this project

### const_units_macros
Containes Macros which can be used by code generated by code_gen

### const_units_uuse
The [uuse!](#uuse) macro.

### code_gen
The crate [const_units_code_gen](
    TODO
    ) has four modules each having a set of defined tasks they are responsible for:
- common
    
    Common Datatypes and commonly used functions accross all of code_gen
- parsing (Step 1)

    Parses the data into structs **without modifying it significantly**
- linking (Step 2)

    Links the Parsed data against each other. 
    This will make heavy use of smart pointers 
- generating (Step 3)

    This uses the linked representation of the config and generates rust code

* * *
## Architecture of the config files
- A directory containing the configuration can be set using the variable DATRA_DIR in the Cargo.toml of **your** Project.
- Note that all foldernames being lowercase
- Folder or filenames enclosed in "" are examples.
- All filenames wich declare content that is expected to be internationalized should use the english singular name.
- A codeblock is an example **content** of the preceding file
- Most "data-containers" can be added to so called [Groups](#groups)
placing them in a folder automaticall adds them to the group.
Alternatively they can be added to other groups through the groups directive
### File Tree:
- DATA_DIR
	- quantities
        - "si_basic"
		    - "length.toml"
			    ```toml
			    description = "optional description"
			    ```
        - "basic_physics"
            - group.toml ***optional***
                ```toml
			    description = "optional description"
                inherit = ["si_basic"]

                ```
		    - "velocity.toml"
			    ```toml
			    description = "optional description"
			    # velocity is length over time
			    formula = "length/time"

                [names]
                Deu = "Geschwindigkeit"
			    ```
	- systems
		- "si-extended"
			- system.toml
				```toml
                derive_prefixes = ["kilo" "metric"]
                #makes no sense since kilo is element of metric.
                #just to demonstrate that both groups as well as elements can be used
				[base_dimensions]
				"length" = "meter"
				"mass" = "kilogram"
				"time" = "second"
				"electrical current" = "ampere"
				"thermodynamic temprature" = "kelvin"
				"amount of substance" = "mol"
				"luminous intensity" = "" 
                #not required to have a reference unit
				"Angle" = "degrees"
				"temperature interval" = ""
				"Information" = "bit"
				```
            - "length" *this is a group and is therefore completely optional (see meters_per_second)*
                - "foot.toml"
                    ```toml
                    symbol = "ft"
                    description = "a foot" #optional
                    derive_prefixes = [] #overwrites systemÂ´s config and optional

                    [names]
                    Eng = ["foot" "feet"]
                    
                    [conversions]
                    # 1 ft = ?
                    meter = {factor = 0.3048, accuracy = 4}
                    yard = "1/3"
                    ```
            - "meters_per_second.toml" ***optional** will get auto-generated if meters and second are defined*

                ```toml
                symbol = "m/s"

                derive_prefixes = ["metric"]
                # true is the default
                inherit_names = true
                # this is a composite unit
                [composite]
                meter = 1
                second = -1

                # ALTERNATIVELY
                composite = "meter/second"
                ```


            
	- prefixes
		- "binary" 
			- "kilob.toml"
				```toml
				factor = 1024 
                # floats and fractions are also possible
                # e.g. 1.2 or "1/2" (Note the ")
				[names]
				Eng = ["kilob" "kb"]
                "Deu, Ita" = ["Eng"] #DO NOTE THE LIST WITH ONLY ONE ELEMENT
				```
        - "metric"
            - "kilo.toml"
                ```toml
                factor = 1000
                groups = ["binary"] # adds this to the binary group
				[names]
				Eng = ["kilob" "kb"] 	
                ```
    
    - units
        
        ***declaring units here IS possible, but it is recommended to add units to their according systems.
        (systems can inherit units of other systems too)***
        - "common_time"
            - "hour.toml"
            ```toml
            symbol = "h" #this is optional
            [names]
            Eng = ["hours" "hours"]
            Deu = "Stunde(n)
            ```
### Names
To allow internationalization translations can be supplied using the `[names]` table.

The key must be a valid [ISO-639](https://github.com/johnstonskj/rust-codes) ID. Alternatively it can also be a comma seperated list of these codes.

As a value you can specify either just a String or a array of two strings. Supplying just a String means that the plural and singular are the same. Supplying two results in the first String being treated as the singular and the second one being treated as the plural

```rust
Either<String, (String, String)>
```

You can specify another language in a single element List (`["Eng"]`) as a value which uses the languages defined translation.
```toml
"Deu, Ita" = ["Eng"] #DO NOTE THE LIST WITH ONLY ONE ELEMENT
```

### Groups
A Group is a collection of data stored in "data-containers".
Most "data-containers" can be added to a group. Placing them in a folder automatically adds them to the group with the folder name.

Having multiple nested folders adds the deeper groups as sub-groups to the group above them:
e.g:

- "A"
    - "e.toml"
    - "B"
        - "f.toml"
        - "C"
            - "g.toml"
            
    - "D"
        - "h.toml"

TOML or Group | Is in Group A | B   | C     | D     |
-|-|-|-|-|
e.toml        | Yes           | No  | No    | No    |
B             | Yes           |  -  | No    | No    |
f.toml        | Yes           | Yes | No    | No    |
C             | Yes           | Yes | -     | No    |
g.toml        | Yes           | Yes | Yes   | No    |
D             | Yes           | No  | No    | -     |
h.toml        | Yes           | No  | No    | Yes   |



Alternatively "data-containers" can be added to other groups through the groups directive

Another way to add all of the elements of Group A to Group B would be. To add a file (group.toml) to a Folder referencing B with the following content: 
```toml
description = "optional description"
inherit = ["A"]
```


To reference the Group featuring all Elements wich are either present in A or B or both you can just write `_A_or_B`
analogously:

| description | mathematical| group name |
|-|-|-|
|either **or** both|$$ A \lor B $$|`_A_or_B`|
|either **but not** both|$$ A \oplus B $$|`_A_xor_B`|
|both|$$ A \land B $$|`_A_and_B`|

### Unit

```rust
struct UnitSer {
    symbol: String,
    description: Option<String>,
    names: Option<HashMap<String, NameSer>>,
    //if supplied on composite unit then this will function as a overwrite
    derive_prefixes: Option<Vec<String>>,
    conversions: Option<HashMap<String, ConversionSer>>
    //if supplied on composite unit then this will function as a overwrite
    composite: Option<HashMap<String, i8>>,
}

#[serde(transparent)]
struct ConversionSerSer {
    #[serde(with = "either::serde_untagged")]
    inner: Either<FactorSer, ConversionWAcc>,
}

#[derive(Serialize, Deserialize, Clone)]
pub(crate) struct ConversionWAcc {
    pub(crate) factor: FactorSer,
    pub(crate) accuracy: Option<i64>, // None => exact
}

#[serde(transparent)]
pub struct FactorSer {
    #[serde(with = "either::serde_untagged")]
    pub(crate) inner: Either<f64, String>,
    // String must be a valid fraction expression. e.g. "1/2"
}
```


# UUse
Takes in a comma seperated list containing names of units that should be included / generated in the place of invocation.
The unit ident is expected to look like this:
"milli_meter"
defined as EBNF:
```EBNF
ident = prefix "_" base_name.
prefix = lowercase {lowercase}.
base_name = lowercase {lowercase}.
```
***
```rust
uuse!(milli_meter);
```
expands to:
```rust
TODO
```
