# Architecture of const_units as well as config files


## Architecture of const_units

### global_types
Contains types that are needed in multiple other crates of this project

### const_units_macros
Containes Macros which can be used by code generated by code_gen

### const_units_uuse
The [uuse!](#uuse) macro.

### code_gen
The crate [const_units_code_gen](
    TODO
    ) has four modules each having a set of defined tasks they are responsible for:
- common
    
    Common Datatypes and commonly used functions accross all of code_gen
- parsing (Step 1)

    Parses the data into structs **without modifying it significantly**
- linking (Step 2)

    Links the Parsed data against each other. 
    This will make heavy use of graphs
- generating (Step 3)

    This uses the linked representation of the config and generates rust code

* * *
## Architecture of the config files
- A directory containing the configuration can be set using the variable DATRA_DIR in the Cargo.toml of **your** Project.
- Note that all foldernames being lowercase
- Folder or filenames enclosed in "" are examples.
- All filenames wich declare content that is expected to be internationalized should use the english singular name.
- A codeblock is an example **content** of the preceding file
- Most "data-containers" can be added to so called [Groups](#groups)
placing them in a folder automaticall adds them to the group.
Alternatively they can be added to other groups through the groups directive
### File Tree:
- DATA_DIR
	- quantities
        - "si_basic"
		    - "length.toml"
			    ```toml
			    description = "optional description"
			    ```
        - "basic_physics"
            - group.toml ***optional***
                ```toml
			    description = "optional description"
                inherit = ["si_basic"]

                ```
		    - "velocity.toml"
			    ```toml
			    description = "optional description"

                [names]
                Deu = "Geschwindigkeit"
			    ```
	- systems
		- "si-extended"
			- system.toml
				```toml
                derive_prefixes = ["kilo" "metric"]
                #makes no sense since kilo is element of metric.
                #just to demonstrate that both groups as well as elements can be used
				[base_dimensions]
				"length" = "meter"
				"mass" = "kilogram"
				"time" = "second"
				"electrical current" = "ampere"
				"thermodynamic temprature" = "kelvin"
				"amount of substance" = "mol"
                #not required to have a reference unit
				"luminous intensity" = "" 
				"angle" = "degrees"
				"temperature interval" = ""
				"information" = "bit"

                # base quantites already enlisted in base_dimensions
                [quantities]
                "velocity" = "length / time"
				```
            - "length" *this is a group and is therefore completely optional (see meters_per_second)*
                - "foot.toml"
                    ```toml
                    symbol = "ft"
                    description = "a foot" #optional
                    derive_prefixes = [] #overwrites systemÂ´s config and optional

                    [names]
                    Eng = ["foot" "feet"]
                    
                    [conversions]
                    # 1 ft = ?
                    meter = {factor = 0.3048, accuracy = 4}
                    yard = "1/3"
                    ```
            - "meters_per_second.toml" ***optional** will get auto-generated if meters and second are defined*

                ```toml
                symbol = "m/s"

                derive_prefixes = ["metric"]
                # true is the default
                inherit_names = true
                # this is a composite unit
                [composite]
                meter = 1
                second = -1

                # ALTERNATIVELY
                composite = "meter/second"
                ```


            
	- prefixes
		- "binary" 
			- "kilob.toml"
				```toml
				factor = 1024 
                # floats and fractions are also possible
                # e.g. 1.2 or "1/2" (Note the ")
				[names]
				Eng = ["kilob" "kb"]
                "Deu, Ita" = ["Eng"] #DO NOTE THE LIST WITH ONLY ONE ELEMENT
				```
        - "metric"
            - "kilo.toml"
                ```toml
                factor = 1000
                groups = ["binary"] # adds this to the binary group
				[names]
				Eng = ["kilob" "kb"] 	
                ```
    
    - units
        
        ***declaring units here IS possible, but it is recommended to add units to their according systems.***

        ***systems can only inherit units from here though***
        - "common_time"
            - "hour.toml" ***hour is defined here as it is such a common unit that other systems, for example in fantasy games, will probably refer to it too***
            ```toml
            symbol = "h" #this is optional
            [names]
            Eng = ["hours" "hours"]
            Deu = "Stunde(n)
            ```
### Names
To allow internationalization translations can be supplied using the `[names]` table.

The key must be a valid [ISO-639](https://github.com/johnstonskj/rust-codes) ID. Alternatively it can also be a comma seperated list of these codes.

As a value you can specify either just a String or a array of two strings. Supplying just a String means that the plural and singular are the same. Supplying two results in the first String being treated as the singular and the second one being treated as the plural

You can specify another language in a single element List (`["Eng"]`) as a value which uses the languages defined translation.
```toml
"Deu, Ita" = ["Eng"] #DO NOTE THE LIST WITH ONLY ONE ELEMENT
```

### Groups
A Group is a collection of data stored in "data-containers".
Most "data-containers" can be added to a group. Placing them in a folder automatically adds them to the group with the folder name.

#### Group Names
A Group has a ***unique*** Identifier to all other groups.

The Identifier is **case-sensitive** while referencing the group.

Decleration is case-insensitive however.

The build script will throw a hard error if two groups contain the same characters in all lowercase.

#### Naming Conventions
The build script will throw a warning if these are misused
- Unit -> lower_camel
- Prefixes -> lower_camel
- Quantities -> UpperCamel
- Systems -> UPPER_SNAKE


Having multiple nested folders adds the deeper groups as sub-groups to the group above them:
e.g:

- "A"
    - "e.toml"
    - "B"
        - "f.toml"
        - "C"
            - "g.toml"
            
    - "D"
        - "h.toml"

TOML or Group | Is in Group A | B   | C     |D      |
-|-|-|-|-|
e.toml        | Yes           | No  | No    | No    |
B             | Yes           |  -  | No    | No    |
f.toml        | Yes           | Yes | No    | No    |
C             | Yes           | Yes | -     | No    |
g.toml        | Yes           | Yes | Yes   | No    |
D             | Yes           | No  | No    | -     |
h.toml        | Yes           | No  | No    | Yes   |



Alternatively "data-containers" can be added to other groups through the groups directive

Another way to add all of the elements of Group A to Group B would be. To add a file (group.toml) to a Folder referencing B with the following content: 
```toml
description = "optional description"
inherit = ["A"]
```


To reference the Group featuring all Elements wich are either present in A or B or both you can just write `_A_or_B`
analogously:

| description | mathematical| group name |
|-|-|-|
|either **or** both|$$ A \lor B $$|`_A_or_B`|
|either **but not** both|$$ A \oplus B $$|`_A_xor_B`|
|both|$$ A \land B $$|`_A_and_B`|

# Conversions
Units of each quantities will be stored in a graph with edges being the conversion factors for **directly** converting between them. Conversion between units that do not have an edge / specified converion factor will happen along the path where the least amount of precision is lost.

E. g: 

    convert:        millimeter -> kilometer
    is equivalent to:   millimeter -EXACT-> 1/1000 * meter -EXACT-> 1/1000 * (1/1000 * kilometer)
    is optimized to: millimeter -EXACT-> 1/1_000_000 * meter





# UUse
Takes in a comma seperated list containing names of units that should be included / generated in the place of invocation.
The unit ident is expected to look like this:
"milli_meter"
defined as EBNF:
```EBNF
ident = prefix "_" base_name.
prefix = lowercase {lowercase}.
base_name = lowercase {lowercase}.
```
***
```rust
uuse!(milli_meter);
```
expands to:
```rust
TODO
```
